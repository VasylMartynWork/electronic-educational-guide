import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as r,e as t}from"./app-CYOwO63N.js";const i={},o=t(`<p>Масив представляє набір однотипних даних. Оголошення масиву схоже на оголошення змінної за винятком, що після вказівки типу ставляться квадратні дужки:</p><pre><code>тип_змінної[] назва_масиву;
</code></pre><p>Наприклад, визначимо масив цілих чисел:</p><pre><code>int[] numbers;
</code></pre><p>Після визначення змінної масиву ми можемо надати їй певне значення:</p><pre><code>int[] nums = new int[4];
</code></pre><p>Тут спочатку ми оголосили масив nums, який зберігатиме дані типу int. Далі використовуючи операцію new, ми виділили пам&#39;ять для 4 елементів масиву: new int[4]. Число 4 ще називається довжиною масиву. При такому визначенні всі елементи набувають значення за замовчуванням, яке передбачено для їх типу. Для типу int значення за замовчуванням - 0.</p><p>Також ми одразу можемо вказати значення для цих елементів:</p><pre><code>int[] nums2 = new int[4] { 1, 2, 3, 5 };
 
int[] nums3 = new int[] { 1, 2, 3, 5 };
 
int[] nums4 = new[] { 1, 2, 3, 5 };
 
int[] nums5 = {1, 2, 3, 5};
</code></pre><p>Усі перелічені вище методи будуть рівноцінні.</p><p>Подібним чином можна визначати масиви інших типів, наприклад масив значень типу string:</p><pre><code>string[] people = {&quot;Tom&quot;, &quot;Sam&quot;, &quot;Bob&quot;};
</code></pre><p>Починаючи з версії C# 12 для визначення масивів можна використовувати вирази колекцій, які передбачають укладання елементів масиву в квадратні дужки:</p><pre><code>int[] nums1 = [1, 2, 3, 5];
int[] nums2 = []; // Порожній масив
</code></pre><h2 id="індекси-та-одержання-елементів-масиву" tabindex="-1"><a class="header-anchor" href="#індекси-та-одержання-елементів-масиву"><span>Індекси та одержання елементів масиву</span></a></h2><p>Для звернення елементів масиву використовуються індекси. Індекс представляє номер елемента в масиві, при цьому нумерація починається з нуля, тому індекс першого елемента дорівнюватиме 0, індекс четвертого елемента - 3.</p><p>Використовуючи індекси, ми можемо отримати елементи масиву:</p><pre><code>int[] numbers = { 1, 2, 3, 5 };
 
// Отримання елемента масиву
Console.WriteLine(numbers[3]); // 5
 
// отримання елемента масиву в змінну
var n = numbers [1]; // 2
Console.WriteLine(n); // 2
</code></pre><p>Також ми можемо змінити елемент масиву за індексом:</p><pre><code>int[] numbers = { 1, 2, 3, 5 };
 
// Змінимо другий елемент масиву
numbers[1] = 505;
 
Console.WriteLine(numbers[1]); // 505
</code></pre><p>І оскільки у нас масив визначений лише для 4 елементів, то ми не можемо звернутися, наприклад, до шостого елемента. Якщо так спробуємо зробити, ми отримаємо помилку під час виконання:</p><pre><code>int[] numbers = { 1, 2, 3, 5 };
 
Console.WriteLine(numbers[6]); //! Помилка - у масиві лише 4 елементи
</code></pre><h2 id="властивість-length-та-довжина-масиву" tabindex="-1"><a class="header-anchor" href="#властивість-length-та-довжина-масиву"><span>Властивість Length та довжина масиву</span></a></h2><p>Кожен масив має властивість Length, що зберігає довжину масиву. Наприклад, отримаємо довжину виществореного масива numbers:</p><pre><code>int[] numbers = { 1, 2, 3, 5 };
 
Console.WriteLine(numbers.Length); // 4
</code></pre><p>Для отримання довжини масиву після назви масиву через крапку вказується властивість Length: numbers.Length.</p><h2 id="отримання-елементів-з-кінця-масиву" tabindex="-1"><a class="header-anchor" href="#отримання-елементів-з-кінця-масиву"><span>Отримання елементів з кінця масиву</span></a></h2><p>Завдяки наявності властивості Length, ми можемо обчислити індекс останнього елемента масиву - це довжина масиву - 1. Наприклад, якщо довжина масиву - 4 (тобто масив має 4 елементи), то індекс останнього елемента дорівнюватиме 3. І, використовуючи властивість Length, ми можемо легко отримати елементи з кінця масиву:</p><pre><code>int[] numbers = {1, 2, 3, 5};
 
Console.WriteLine(numbers[numbers.Length - 1]); // 5 - перший з кінця або останній елемент
Console.WriteLine(numbers[numbers.Length - 2]); // 3 - другий з кінця чи передостанній елемент
Console.WriteLine(numbers[numbers.Length - 3]); // 2 – третій елемент з кінця
</code></pre><p>Однак при подібному підході вирази типу numbers.Length - 1, сенс яких полягає в тому, щоб отримати якийсь певний елемент з кінця масиву, обтяжують код. І, починаючи, з версії C# 8.0 в мову було додано спеціальний оператор ^, за допомогою якого можна задати індекс відносно кінця колекції.</p><p>Перепишемо попередній приклад, застосовуючи оператор ^:</p><pre><code>int[] numbers = {1, 2, 3, 5};
 
Console.WriteLine(numbers[^1]); // 5 - перший з кінця або останній елемент
Console.WriteLine(numbers[^2]); // 3 - другий з кінця чи передостанній елемент
Console.WriteLine(numbers[^3]); // 2 – третій елемент з кінця
</code></pre><h2 id="перебір-масивів" tabindex="-1"><a class="header-anchor" href="#перебір-масивів"><span>Перебір масивів</span></a></h2><p>Для перебору масивів можна використовувати різні типи циклів. Наприклад, цикл foreach:</p><pre><code>int[] numbers = { 1, 2, 3, 4, 5 };
foreach (int i in numbers)
{
     Console.WriteLine(i);
}
</code></pre><p>Тут як контейнер виступає масив даних типу int. Тому ми оголошуємо змінну з типом int</p><p>Подібні дії ми можемо зробити і за допомогою циклу for:</p><pre><code>int[] numbers = { 1, 2, 3, 4, 5 };
for (int i = 0; i &lt; numbers.Length; i++)
{
     Console.WriteLine(numbers[i]);
}
</code></pre><p>У той же час цикл for більш гнучкий у порівнянні з foreach. Якщо foreach послідовно витягує елементи контейнера і тільки для читання, то в циклі for ми можемо перескакувати на кілька елементів вперед залежно від збільшення лічильника, а також можемо змінювати елементи:</p><pre><code>int[] numbers = { 1, 2, 3, 4, 5 };
for (int i = 0; i &lt; numbers.Length; i++)
{
     numbers[i] = numbers[i] * 2;
     Console.WriteLine(numbers[i]);
}
</code></pre><p>Також можна використовувати і другі види циклів, наприклад, while:</p><pre><code>int[] numbers = { 1, 2, 3, 4, 5 };
int i = 0;
while(i &lt; numbers.Length)
{
     Console.WriteLine(numbers[i]);
     i++;
}
</code></pre><h2 id="багатовимірні-масиви" tabindex="-1"><a class="header-anchor" href="#багатовимірні-масиви"><span>Багатовимірні масиви</span></a></h2><p>Масиви характеризуються таким поняттям як ранг чи кількість вимірів. Вище ми розглядали масиви, які мають один вимір (тобто їх ранг дорівнює 1) – такі масиви можна представляти у вигляді ряду (рядка чи стовпця) елемента. Але масиви також бувають багатовимірними. У таких масивів кількість вимірів (тобто ранг) більша за 1.</p><p>Масиви які мають два виміри (ранг дорівнює 2) називають двовимірними. Наприклад, створимо одномірний та двомірний масиви, які мають однакові елементи:</p><pre><code>int[] nums1 = new int[] { 0, 1, 2, 3, 4, 5};
 
int[,] nums2 = { { 0, 1, 2 }, { 3, 4, 5 } };
</code></pre><p>Візуально обидва масиви можна представити так:</p><p>Одновимірний масив nums1</p><pre><code>0 | 1 | 2 | 3 | 4 | 5
</code></pre><p>Двовимірний масив nums2</p><pre><code>0 | 1 | 2
3 | 4 | 5
</code></pre><p>Оскільки масив nums2 двовимірний, він є простою таблицею. Усі можливі способи визначення двовимірних масивів:</p><pre><code>int[,] nums1;
int[,] nums2 = new int[2, 3];
int[,] nums3 = new int[2, 3] { { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums4 = new int[,] { { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums5 = new [,]{ { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums6 = { { 0, 1, 2 }, { 3, 4, 5 } };
</code></pre><p>Масиви можуть мати і більшу кількість вимірів. Оголошення тривимірного масиву могло б виглядати так:</p><pre><code>int[,,] nums3 = new int[2, 3, 4];
</code></pre><p>Відповідно можуть бути і чотиривимірні масиви та масиви з великою кількістю вимірів. Але на практиці зазвичай використовуються одновимірні та двомірні масиви.</p><p>Певну складність може становити перебір багатовимірного масиву. Насамперед треба враховувати, що довжина такого масиву – це сукупна кількість елементів.</p><pre><code>int[,] numbers = { { 1, 2, 3 }, { 4, 5, 6 }};
foreach (int i in numbers)
     Console.Write($&quot;{i}&quot;);
</code></pre><p>У даному випадку довжина масиву номерів дорівнює 6. І цикл foreach виводить всі елементи масиву в рядок:</p><pre><code>1 2 3 4 5 6
</code></pre><p>Але якщо ми хочемо окремо пробігтися по кожному рядку в таблиці? В цьому випадку треба одержати кількість елементів у розмірності. Зокрема, кожен масив має метод GetUpperBound(номер_розмірності), який повертає індекс останнього елемента у певній розмірності. І якщо ми говоримо безпосередньо про двомірний масив, то перша розмірність (з індексом 0) по суті це і є таблиця. І за допомогою виразу</p><pre><code>numbers.GetUpperBound(0) + 1
</code></pre><p>можна отримати кількість рядків таблиці, поданої двовимірним масивом. А через</p><pre><code>numbers.Length / кількість_рядків
</code></pre><p>можна отримати кількість елементів у кожному рядку:</p><pre><code>int[,] numbers = { { 1, 2, 3 }, { 4, 5, 6 }};
 
int rows = numbers.GetUpperBound(0) + 1; // кількість рядків
int columns = numbers.Length/rows; // кількість стовпців
// або так
// int columns = numbers.GetUpperBound(1) + 1;
 
for (int i = 0; i &lt; rows; i++)
{
     for (int j = 0; j &lt;columns; j++)
     {
         Console.Write($&quot;{numbers[i, j]} \\t&quot;);
     }
     Console.WriteLine();
}

1 | 2 | 3
4 | 5 | 6
</code></pre><h2 id="масив-масивів" tabindex="-1"><a class="header-anchor" href="#масив-масивів"><span>Масив масивів</span></a></h2><p>Від багатовимірних масивів треба відрізняти масив масивів або так званий зубчастий масив:</p><pre><code>int[][] nums = new int[3][];
nums[0] = new int[2] {1, 2}; // Виділяємо пам&#39;ять для першого підмасиву
nums[1] = new int[3] {1, 2, 3}; // Виділяємо пам&#39;ять для другого підмасиву
nums[2] = new int[5] {1, 2, 3, 4, 5}; // виділяємо пам&#39;ять для третього підмасиву
</code></pre><p>Тут дві групи квадратних дужок вказують, що це масив масивів, тобто такий масив, який у свою чергу містить інші масиви. Причому довжина масиву вказується лише у перших квадратних дужках, всі наступні квадратні дужки мають бути порожні: new int[3][]. В даному випадку у нас масив nums містить три масиви. Причому розмірність кожного з цих масивів може збігатися.</p><p>Альтернативне визначення масиву масивів:</p><pre><code>int[][] numbers = {
     new int[] { 1, 2 },
     new int[] { 1, 2, 3 },
     new int[] { 1, 2, 3, 4, 5 }
};
</code></pre><p>Зубчастий масив nums 1 | 2 1 | 2 | 3 1 | 2 | 3 | 4 | 5</p><p>Використовуючи вкладені цикли, можна перебирати зубчасті масиви. Наприклад:</p><pre><code>int[][] numbers = new int[3][];
numbers[0] = new int[] { 1, 2 };
numbers[1] = new int[] { 1, 2, 3 };
numbers[2] = new int[] { 1, 2, 3, 4, 5 };
foreach(int[] row in numbers)
{
     foreach(int number in row)
     {
         Console.Write($&quot;{number} \\t&quot;);
     }
     Console.WriteLine();
}
 
// Перебір за допомогою циклу for
for (int i = 0; i&lt;numbers.Length;i++)
{
     for (int j = 0; j&lt;numbers[i].Length; j++)
     {
         Console.Write($&quot;{numbers[i][j]} \\t&quot;);
     }
     Console.WriteLine();
}
</code></pre><p>Основні поняття масивів Підсумовуємо основні поняття масивів:</p><p>Ранг (rank): кількість вимірів масиву</p><p>Довжина виміру (dimension length): довжина окремого виміру масиву</p><p>Довжина масиву (array length): кількість всіх елементів масиву</p><p>Наприклад, візьмемо масив</p><pre><code>int[,] numbers = new int[3, 4];
</code></pre><p>Масив numbers двомірний, тобто він має два виміри, тому його ранг дорівнює 2. Довжина першого виміру - 3, довжина другого виміру - 4. Довжина масиву (тобто загальна кількість елементів) - 12.</p>`,82),p=[o];function s(u,c){return e(),r("div",null,p)}const d=n(i,[["render",s],["__file","topic11.html.vue"]]),a=JSON.parse('{"path":"/theory/theory2/topic11.html","title":"Масиви","lang":"en-US","frontmatter":{"title":"Масиви"},"headers":[{"level":2,"title":"Індекси та одержання елементів масиву","slug":"індекси-та-одержання-елементів-масиву","link":"#індекси-та-одержання-елементів-масиву","children":[]},{"level":2,"title":"Властивість Length та довжина масиву","slug":"властивість-length-та-довжина-масиву","link":"#властивість-length-та-довжина-масиву","children":[]},{"level":2,"title":"Отримання елементів з кінця масиву","slug":"отримання-елементів-з-кінця-масиву","link":"#отримання-елементів-з-кінця-масиву","children":[]},{"level":2,"title":"Перебір масивів","slug":"перебір-масивів","link":"#перебір-масивів","children":[]},{"level":2,"title":"Багатовимірні масиви","slug":"багатовимірні-масиви","link":"#багатовимірні-масиви","children":[]},{"level":2,"title":"Масив масивів","slug":"масив-масивів","link":"#масив-масивів","children":[]}],"git":{"createdTime":1712559663000,"updatedTime":1712875693000,"contributors":[{"name":"VasylMartynWork","email":"killermbjustthink@gmail.com","commits":2}]},"readingTime":{"minutes":4.74,"words":1422},"filePathRelative":"theory/theory2/topic11.md","localizedDate":"April 8, 2024"}');export{d as comp,a as data};
